{
  "version": 3,
  "sources": ["../../.pnpm/eventsource-parser@1.0.0/node_modules/eventsource-parser/src/parse.ts", "../../.pnpm/ai@2.2.12_react@18.2.0_solid-js@1.7.11_svelte@4.2.0_vue@3.3.4/node_modules/ai/dist/index.mjs"],
  "sourcesContent": ["/**\n * EventSource/Server-Sent Events parser\n * @see https://html.spec.whatwg.org/multipage/server-sent-events.html\n *\n * Based on code from the {@link https://github.com/EventSource/eventsource | EventSource module},\n * which is licensed under the MIT license. And copyrighted the EventSource GitHub organisation.\n */\nimport type {EventSourceParseCallback, EventSourceParser} from './types.js'\n\n/**\n * Creates a new EventSource parser.\n *\n * @param onParse - Callback to invoke when a new event is parsed, or a new reconnection interval\n *                  has been sent from the server\n *\n * @returns A new EventSource parser, with `parse` and `reset` methods.\n * @public\n */\nexport function createParser(onParse: EventSourceParseCallback): EventSourceParser {\n  // Processing state\n  let isFirstChunk: boolean\n  let buffer: string\n  let startingPosition: number\n  let startingFieldLength: number\n\n  // Event state\n  let eventId: string | undefined\n  let eventName: string | undefined\n  let data: string\n\n  reset()\n  return {feed, reset}\n\n  function reset(): void {\n    isFirstChunk = true\n    buffer = ''\n    startingPosition = 0\n    startingFieldLength = -1\n\n    eventId = undefined\n    eventName = undefined\n    data = ''\n  }\n\n  function feed(chunk: string): void {\n    buffer = buffer ? buffer + chunk : chunk\n\n    // Strip any UTF8 byte order mark (BOM) at the start of the stream.\n    // Note that we do not strip any non - UTF8 BOM, as eventsource streams are\n    // always decoded as UTF8 as per the specification.\n    if (isFirstChunk && hasBom(buffer)) {\n      buffer = buffer.slice(BOM.length)\n    }\n\n    isFirstChunk = false\n\n    // Set up chunk-specific processing state\n    const length = buffer.length\n    let position = 0\n    let discardTrailingNewline = false\n\n    // Read the current buffer byte by byte\n    while (position < length) {\n      // EventSource allows for carriage return + line feed, which means we\n      // need to ignore a linefeed character if the previous character was a\n      // carriage return\n      // @todo refactor to reduce nesting, consider checking previous byte?\n      // @todo but consider multiple chunks etc\n      if (discardTrailingNewline) {\n        if (buffer[position] === '\\n') {\n          ++position\n        }\n        discardTrailingNewline = false\n      }\n\n      let lineLength = -1\n      let fieldLength = startingFieldLength\n      let character: string\n\n      for (let index = startingPosition; lineLength < 0 && index < length; ++index) {\n        character = buffer[index]\n        if (character === ':' && fieldLength < 0) {\n          fieldLength = index - position\n        } else if (character === '\\r') {\n          discardTrailingNewline = true\n          lineLength = index - position\n        } else if (character === '\\n') {\n          lineLength = index - position\n        }\n      }\n\n      if (lineLength < 0) {\n        startingPosition = length - position\n        startingFieldLength = fieldLength\n        break\n      } else {\n        startingPosition = 0\n        startingFieldLength = -1\n      }\n\n      parseEventStreamLine(buffer, position, fieldLength, lineLength)\n\n      position += lineLength + 1\n    }\n\n    if (position === length) {\n      // If we consumed the entire buffer to read the event, reset the buffer\n      buffer = ''\n    } else if (position > 0) {\n      // If there are bytes left to process, set the buffer to the unprocessed\n      // portion of the buffer only\n      buffer = buffer.slice(position)\n    }\n  }\n\n  function parseEventStreamLine(\n    lineBuffer: string,\n    index: number,\n    fieldLength: number,\n    lineLength: number\n  ) {\n    if (lineLength === 0) {\n      // We reached the last line of this event\n      if (data.length > 0) {\n        onParse({\n          type: 'event',\n          id: eventId,\n          event: eventName || undefined,\n          data: data.slice(0, -1), // remove trailing newline\n        })\n\n        data = ''\n        eventId = undefined\n      }\n      eventName = undefined\n      return\n    }\n\n    const noValue = fieldLength < 0\n    const field = lineBuffer.slice(index, index + (noValue ? lineLength : fieldLength))\n    let step = 0\n\n    if (noValue) {\n      step = lineLength\n    } else if (lineBuffer[index + fieldLength + 1] === ' ') {\n      step = fieldLength + 2\n    } else {\n      step = fieldLength + 1\n    }\n\n    const position = index + step\n    const valueLength = lineLength - step\n    const value = lineBuffer.slice(position, position + valueLength).toString()\n\n    if (field === 'data') {\n      data += value ? `${value}\\n` : '\\n'\n    } else if (field === 'event') {\n      eventName = value\n    } else if (field === 'id' && !value.includes('\\u0000')) {\n      eventId = value\n    } else if (field === 'retry') {\n      const retry = parseInt(value, 10)\n      if (!Number.isNaN(retry)) {\n        onParse({type: 'reconnect-interval', value: retry})\n      }\n    }\n  }\n}\n\nconst BOM = [239, 187, 191]\n\nfunction hasBom(buffer: string) {\n  return BOM.every((charCode: number, index: number) => buffer.charCodeAt(index) === charCode)\n}\n", "// streams/ai-stream.ts\nimport {\n  createParser\n} from \"eventsource-parser\";\nfunction createEventStreamTransformer(customParser) {\n  const textDecoder = new TextDecoder();\n  let eventSourceParser;\n  return new TransformStream({\n    async start(controller) {\n      eventSourceParser = createParser(\n        (event) => {\n          if (\"data\" in event && event.type === \"event\" && event.data === \"[DONE]\" || // Replicate doesn't send [DONE] but does send a 'done' event\n          // @see https://replicate.com/docs/streaming\n          event.event === \"done\") {\n            controller.terminate();\n            return;\n          }\n          if (\"data\" in event) {\n            const parsedMessage = customParser ? customParser(event.data) : event.data;\n            if (parsedMessage)\n              controller.enqueue(parsedMessage);\n          }\n        }\n      );\n    },\n    transform(chunk) {\n      eventSourceParser.feed(textDecoder.decode(chunk));\n    }\n  });\n}\nfunction createCallbacksTransformer(cb) {\n  const textEncoder = new TextEncoder();\n  let aggregatedResponse = \"\";\n  const callbacks = cb || {};\n  return new TransformStream({\n    async start() {\n      if (callbacks.onStart)\n        await callbacks.onStart();\n    },\n    async transform(message, controller) {\n      controller.enqueue(textEncoder.encode(message));\n      if (callbacks.onToken)\n        await callbacks.onToken(message);\n      if (callbacks.onCompletion)\n        aggregatedResponse += message;\n    },\n    async flush() {\n      const isOpenAICallbacks = isOfTypeOpenAIStreamCallbacks(callbacks);\n      if (callbacks.onCompletion) {\n        await callbacks.onCompletion(aggregatedResponse);\n      }\n      if (callbacks.onFinal && !isOpenAICallbacks) {\n        await callbacks.onFinal(aggregatedResponse);\n      }\n    }\n  });\n}\nfunction isOfTypeOpenAIStreamCallbacks(callbacks) {\n  return \"experimental_onFunctionCall\" in callbacks;\n}\nfunction trimStartOfStreamHelper() {\n  let isStreamStart = true;\n  return (text) => {\n    if (isStreamStart) {\n      text = text.trimStart();\n      if (text)\n        isStreamStart = false;\n    }\n    return text;\n  };\n}\nfunction AIStream(response, customParser, callbacks) {\n  if (!response.ok) {\n    if (response.body) {\n      const reader = response.body.getReader();\n      return new ReadableStream({\n        async start(controller) {\n          const { done, value } = await reader.read();\n          if (!done) {\n            const errorText = new TextDecoder().decode(value);\n            controller.error(new Error(`Response error: ${errorText}`));\n          }\n        }\n      });\n    } else {\n      return new ReadableStream({\n        start(controller) {\n          controller.error(new Error(\"Response error: No response body\"));\n        }\n      });\n    }\n  }\n  const responseBodyStream = response.body || createEmptyReadableStream();\n  return responseBodyStream.pipeThrough(createEventStreamTransformer(customParser)).pipeThrough(createCallbacksTransformer(callbacks));\n}\nfunction createEmptyReadableStream() {\n  return new ReadableStream({\n    start(controller) {\n      controller.close();\n    }\n  });\n}\nfunction readableFromAsyncIterable(iterable) {\n  let it = iterable[Symbol.asyncIterator]();\n  return new ReadableStream({\n    async pull(controller) {\n      const { done, value } = await it.next();\n      if (done)\n        controller.close();\n      else\n        controller.enqueue(value);\n    },\n    async cancel(reason) {\n      var _a;\n      await ((_a = it.return) == null ? void 0 : _a.call(it, reason));\n    }\n  });\n}\n\n// shared/utils.ts\nimport { customAlphabet } from \"nanoid/non-secure\";\nvar nanoid = customAlphabet(\n  \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz\",\n  7\n);\nfunction createChunkDecoder(complex) {\n  const decoder = new TextDecoder();\n  if (!complex) {\n    return function(chunk) {\n      if (!chunk)\n        return \"\";\n      return decoder.decode(chunk, { stream: true });\n    };\n  }\n  return function(chunk) {\n    const decoded = decoder.decode(chunk, { stream: true }).split(\"\\n\");\n    return decoded.map(getStreamStringTypeAndValue).filter(Boolean);\n  };\n}\nvar StreamStringPrefixes = {\n  text: 0,\n  function_call: 1,\n  data: 2\n  // user_err: 3?\n};\nvar isStreamStringEqualToType = (type, value) => value.startsWith(`${StreamStringPrefixes[type]}:`) && value.endsWith(\"\\n\");\nvar getStreamString = (type, value) => `${StreamStringPrefixes[type]}:${JSON.stringify(value)}\n`;\nvar getStreamStringTypeAndValue = (line) => {\n  const firstSeperatorIndex = line.indexOf(\":\");\n  const prefix = line.slice(0, firstSeperatorIndex);\n  const type = Object.keys(StreamStringPrefixes).find(\n    (key) => StreamStringPrefixes[key] === Number(prefix)\n  );\n  const val = line.slice(firstSeperatorIndex + 1);\n  let parsedVal = val;\n  if (!val) {\n    return { type, value: \"\" };\n  }\n  try {\n    parsedVal = JSON.parse(val);\n  } catch (e) {\n    console.error(\"Failed to parse JSON value:\", val);\n  }\n  return { type, value: parsedVal };\n};\nvar COMPLEX_HEADER = \"X-Experimental-Stream-Data\";\n\n// streams/stream-data.ts\nvar experimental_StreamData = class {\n  constructor() {\n    this.encoder = new TextEncoder();\n    this.controller = null;\n    // closing the stream is synchronous, but we want to return a promise\n    // in case we're doing async work\n    this.isClosedPromise = null;\n    this.isClosedPromiseResolver = void 0;\n    this.isClosed = false;\n    // array to store appended data\n    this.data = [];\n    this.isClosedPromise = new Promise((resolve) => {\n      this.isClosedPromiseResolver = resolve;\n    });\n    const self = this;\n    this.stream = new TransformStream({\n      start: async (controller) => {\n        self.controller = controller;\n      },\n      transform: async (chunk, controller) => {\n        controller.enqueue(chunk);\n        if (self.data.length > 0) {\n          const encodedData = self.encoder.encode(\n            getStreamString(\"data\", JSON.stringify(self.data))\n          );\n          self.data = [];\n          controller.enqueue(encodedData);\n        }\n      },\n      async flush(controller) {\n        const warningTimeout = process.env.NODE_ENV === \"development\" ? setTimeout(() => {\n          console.warn(\n            \"The data stream is hanging. Did you forget to close it with `data.close()`?\"\n          );\n        }, 3e3) : null;\n        await self.isClosedPromise;\n        if (warningTimeout !== null) {\n          clearTimeout(warningTimeout);\n        }\n        if (self.data.length) {\n          const encodedData = self.encoder.encode(\n            getStreamString(\"data\", JSON.stringify(self.data))\n          );\n          controller.enqueue(encodedData);\n        }\n      }\n    });\n  }\n  async close() {\n    var _a;\n    if (this.isClosed) {\n      throw new Error(\"Data Stream has already been closed.\");\n    }\n    if (!this.controller) {\n      throw new Error(\"Stream controller is not initialized.\");\n    }\n    (_a = this.isClosedPromiseResolver) == null ? void 0 : _a.call(this);\n    this.isClosed = true;\n  }\n  append(value) {\n    if (this.isClosed) {\n      throw new Error(\"Data Stream has already been closed.\");\n    }\n    this.data.push(value);\n  }\n};\nfunction createStreamDataTransformer(experimental_streamData) {\n  if (!experimental_streamData) {\n    return new TransformStream({\n      transform: async (chunk, controller) => {\n        controller.enqueue(chunk);\n      }\n    });\n  }\n  const encoder = new TextEncoder();\n  const decoder = new TextDecoder();\n  return new TransformStream({\n    transform: async (chunk, controller) => {\n      const message = decoder.decode(chunk);\n      controller.enqueue(encoder.encode(getStreamString(\"text\", message)));\n    }\n  });\n}\n\n// streams/openai-stream.ts\nfunction parseOpenAIStream() {\n  const extract = chunkToText();\n  return (data) => {\n    return extract(JSON.parse(data));\n  };\n}\nasync function* streamable(stream) {\n  const extract = chunkToText();\n  for await (const chunk of stream) {\n    const text = extract(chunk);\n    if (text)\n      yield text;\n  }\n}\nfunction chunkToText() {\n  const trimStartOfStream = trimStartOfStreamHelper();\n  let isFunctionStreamingIn;\n  return (json) => {\n    var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j;\n    if (isChatCompletionChunk(json) && ((_c = (_b = (_a = json.choices[0]) == null ? void 0 : _a.delta) == null ? void 0 : _b.function_call) == null ? void 0 : _c.name)) {\n      isFunctionStreamingIn = true;\n      return `{\"function_call\": {\"name\": \"${(_e = (_d = json.choices[0]) == null ? void 0 : _d.delta) == null ? void 0 : _e.function_call.name}\", \"arguments\": \"`;\n    } else if (isChatCompletionChunk(json) && ((_h = (_g = (_f = json.choices[0]) == null ? void 0 : _f.delta) == null ? void 0 : _g.function_call) == null ? void 0 : _h.arguments)) {\n      const argumentChunk = json.choices[0].delta.function_call.arguments;\n      let escapedPartialJson = argumentChunk.replace(/\\\\/g, \"\\\\\\\\\").replace(/\\//g, \"\\\\/\").replace(/\"/g, '\\\\\"').replace(/\\n/g, \"\\\\n\").replace(/\\r/g, \"\\\\r\").replace(/\\t/g, \"\\\\t\").replace(/\\f/g, \"\\\\f\");\n      return `${escapedPartialJson}`;\n    } else if (isFunctionStreamingIn && (((_i = json.choices[0]) == null ? void 0 : _i.finish_reason) === \"function_call\" || ((_j = json.choices[0]) == null ? void 0 : _j.finish_reason) === \"stop\")) {\n      isFunctionStreamingIn = false;\n      return '\"}}';\n    }\n    const text = trimStartOfStream(\n      isChatCompletionChunk(json) && json.choices[0].delta.content ? json.choices[0].delta.content : isCompletion(json) ? json.choices[0].text : \"\"\n    );\n    return text;\n  };\n}\nvar __internal__OpenAIFnMessagesSymbol = Symbol(\n  \"internal_openai_fn_messages\"\n);\nfunction isChatCompletionChunk(data) {\n  return \"choices\" in data && data.choices && data.choices[0] && \"delta\" in data.choices[0];\n}\nfunction isCompletion(data) {\n  return \"choices\" in data && data.choices && data.choices[0] && \"text\" in data.choices[0];\n}\nfunction OpenAIStream(res, callbacks) {\n  const cb = callbacks;\n  let stream;\n  if (Symbol.asyncIterator in res) {\n    stream = readableFromAsyncIterable(streamable(res)).pipeThrough(\n      createCallbacksTransformer(\n        (cb == null ? void 0 : cb.experimental_onFunctionCall) ? {\n          ...cb,\n          onFinal: void 0\n        } : {\n          ...cb\n        }\n      )\n    );\n  } else {\n    stream = AIStream(\n      res,\n      parseOpenAIStream(),\n      (cb == null ? void 0 : cb.experimental_onFunctionCall) ? {\n        ...cb,\n        onFinal: void 0\n      } : {\n        ...cb\n      }\n    );\n  }\n  if (cb && cb.experimental_onFunctionCall) {\n    const functionCallTransformer = createFunctionCallTransformer(cb);\n    return stream.pipeThrough(functionCallTransformer);\n  } else {\n    return stream.pipeThrough(\n      createStreamDataTransformer(cb == null ? void 0 : cb.experimental_streamData)\n    );\n  }\n}\nfunction createFunctionCallTransformer(callbacks) {\n  const textEncoder = new TextEncoder();\n  let isFirstChunk = true;\n  let aggregatedResponse = \"\";\n  let aggregatedFinalCompletionResponse = \"\";\n  let isFunctionStreamingIn = false;\n  let functionCallMessages = callbacks[__internal__OpenAIFnMessagesSymbol] || [];\n  const isComplexMode = callbacks == null ? void 0 : callbacks.experimental_streamData;\n  const decode = createChunkDecoder();\n  return new TransformStream({\n    async transform(chunk, controller) {\n      const message = decode(chunk);\n      aggregatedFinalCompletionResponse += message;\n      const shouldHandleAsFunction = isFirstChunk && message.startsWith('{\"function_call\":');\n      if (shouldHandleAsFunction) {\n        isFunctionStreamingIn = true;\n        aggregatedResponse += message;\n        isFirstChunk = false;\n        return;\n      }\n      if (!isFunctionStreamingIn) {\n        controller.enqueue(\n          isComplexMode ? textEncoder.encode(getStreamString(\"text\", message)) : chunk\n        );\n        return;\n      } else {\n        aggregatedResponse += message;\n      }\n    },\n    async flush(controller) {\n      try {\n        const isEndOfFunction = !isFirstChunk && callbacks.experimental_onFunctionCall && isFunctionStreamingIn;\n        if (isEndOfFunction && callbacks.experimental_onFunctionCall) {\n          isFunctionStreamingIn = false;\n          const payload = JSON.parse(aggregatedResponse);\n          const argumentsPayload = JSON.parse(payload.function_call.arguments);\n          let newFunctionCallMessages = [\n            ...functionCallMessages\n          ];\n          const functionResponse = await callbacks.experimental_onFunctionCall(\n            {\n              name: payload.function_call.name,\n              arguments: argumentsPayload\n            },\n            (result) => {\n              newFunctionCallMessages = [\n                ...functionCallMessages,\n                {\n                  role: \"assistant\",\n                  content: \"\",\n                  function_call: payload.function_call\n                },\n                {\n                  role: \"function\",\n                  name: payload.function_call.name,\n                  content: JSON.stringify(result)\n                }\n              ];\n              return newFunctionCallMessages;\n            }\n          );\n          if (!functionResponse) {\n            controller.enqueue(\n              textEncoder.encode(\n                isComplexMode ? getStreamString(\"function_call\", aggregatedResponse) : aggregatedResponse\n              )\n            );\n            return;\n          } else if (typeof functionResponse === \"string\") {\n            controller.enqueue(\n              isComplexMode ? textEncoder.encode(getStreamString(\"text\", functionResponse)) : textEncoder.encode(functionResponse)\n            );\n            return;\n          }\n          const filteredCallbacks = {\n            ...callbacks,\n            onStart: void 0\n          };\n          callbacks.onFinal = void 0;\n          const openAIStream = OpenAIStream(functionResponse, {\n            ...filteredCallbacks,\n            [__internal__OpenAIFnMessagesSymbol]: newFunctionCallMessages\n          });\n          const reader = openAIStream.getReader();\n          while (true) {\n            const { done, value } = await reader.read();\n            if (done) {\n              break;\n            }\n            controller.enqueue(value);\n          }\n        }\n      } finally {\n        if (callbacks.onFinal && aggregatedFinalCompletionResponse) {\n          await callbacks.onFinal(aggregatedFinalCompletionResponse);\n        }\n      }\n    }\n  });\n}\n\n// streams/streaming-text-response.ts\nvar StreamingTextResponse = class extends Response {\n  constructor(res, init, data) {\n    let processedStream = res;\n    if (data) {\n      processedStream = res.pipeThrough(data.stream);\n    }\n    super(processedStream, {\n      ...init,\n      status: 200,\n      headers: {\n        \"Content-Type\": \"text/plain; charset=utf-8\",\n        [COMPLEX_HEADER]: data ? \"true\" : \"false\",\n        ...init == null ? void 0 : init.headers\n      }\n    });\n  }\n};\nfunction streamToResponse(res, response, init) {\n  response.writeHead((init == null ? void 0 : init.status) || 200, {\n    \"Content-Type\": \"text/plain; charset=utf-8\",\n    ...init == null ? void 0 : init.headers\n  });\n  const reader = res.getReader();\n  function read() {\n    reader.read().then(({ done, value }) => {\n      if (done) {\n        response.end();\n        return;\n      }\n      response.write(value);\n      read();\n    });\n  }\n  read();\n}\n\n// streams/huggingface-stream.ts\nfunction createParser2(res) {\n  const trimStartOfStream = trimStartOfStreamHelper();\n  return new ReadableStream({\n    async pull(controller) {\n      var _a, _b;\n      const { value, done } = await res.next();\n      if (done) {\n        controller.close();\n        return;\n      }\n      const text = trimStartOfStream((_b = (_a = value.token) == null ? void 0 : _a.text) != null ? _b : \"\");\n      if (!text)\n        return;\n      if (value.generated_text != null && value.generated_text.length > 0) {\n        controller.close();\n        return;\n      }\n      if (text === \"</s>\" || text === \"<|endoftext|>\" || text === \"<|end|>\") {\n        controller.close();\n      } else {\n        controller.enqueue(text);\n      }\n    }\n  });\n}\nfunction HuggingFaceStream(res, callbacks) {\n  return createParser2(res).pipeThrough(createCallbacksTransformer(callbacks)).pipeThrough(\n    createStreamDataTransformer(callbacks == null ? void 0 : callbacks.experimental_streamData)\n  );\n}\n\n// streams/cohere-stream.ts\nvar utf8Decoder = new TextDecoder(\"utf-8\");\nasync function processLines(lines, controller) {\n  for (const line of lines) {\n    const { text, is_finished } = JSON.parse(line);\n    if (is_finished === true) {\n      controller.close();\n    } else {\n      controller.enqueue(text);\n    }\n  }\n}\nasync function readAndProcessLines(reader, controller) {\n  let segment = \"\";\n  while (true) {\n    const { value: chunk, done } = await reader.read();\n    if (done) {\n      break;\n    }\n    segment += utf8Decoder.decode(chunk, { stream: true });\n    const linesArray = segment.split(/\\r\\n|\\n|\\r/g);\n    segment = linesArray.pop() || \"\";\n    await processLines(linesArray, controller);\n  }\n  if (segment) {\n    const linesArray = [segment];\n    await processLines(linesArray, controller);\n  }\n  controller.close();\n}\nfunction createParser3(res) {\n  var _a;\n  const reader = (_a = res.body) == null ? void 0 : _a.getReader();\n  return new ReadableStream({\n    async start(controller) {\n      if (!reader) {\n        controller.close();\n        return;\n      }\n      await readAndProcessLines(reader, controller);\n    }\n  });\n}\nfunction CohereStream(reader, callbacks) {\n  return createParser3(reader).pipeThrough(createCallbacksTransformer(callbacks)).pipeThrough(\n    createStreamDataTransformer(callbacks == null ? void 0 : callbacks.experimental_streamData)\n  );\n}\n\n// streams/anthropic-stream.ts\nfunction parseAnthropicStream() {\n  let previous = \"\";\n  return (data) => {\n    const json = JSON.parse(data);\n    if (\"error\" in json) {\n      throw new Error(`${json.error.type}: ${json.error.message}`);\n    }\n    if (!(\"completion\" in json)) {\n      return;\n    }\n    const text = json.completion;\n    if (!previous || text.length > previous.length && text.startsWith(previous)) {\n      const delta = text.slice(previous.length);\n      previous = text;\n      return delta;\n    }\n    return text;\n  };\n}\nasync function* streamable2(stream) {\n  for await (const chunk of stream) {\n    const text = chunk.completion;\n    if (text)\n      yield text;\n  }\n}\nfunction AnthropicStream(res, cb) {\n  if (Symbol.asyncIterator in res) {\n    return readableFromAsyncIterable(streamable2(res)).pipeThrough(createCallbacksTransformer(cb)).pipeThrough(createStreamDataTransformer(cb == null ? void 0 : cb.experimental_streamData));\n  } else {\n    return AIStream(res, parseAnthropicStream(), cb).pipeThrough(\n      createStreamDataTransformer(cb == null ? void 0 : cb.experimental_streamData)\n    );\n  }\n}\n\n// streams/langchain-stream.ts\nfunction LangChainStream(callbacks) {\n  const stream = new TransformStream();\n  const writer = stream.writable.getWriter();\n  const runs = /* @__PURE__ */ new Set();\n  const handleError = async (e, runId) => {\n    runs.delete(runId);\n    await writer.ready;\n    await writer.abort(e);\n  };\n  const handleStart = async (runId) => {\n    runs.add(runId);\n  };\n  const handleEnd = async (runId) => {\n    runs.delete(runId);\n    if (runs.size === 0) {\n      await writer.ready;\n      await writer.close();\n    }\n  };\n  return {\n    stream: stream.readable.pipeThrough(createCallbacksTransformer(callbacks)).pipeThrough(\n      createStreamDataTransformer(callbacks == null ? void 0 : callbacks.experimental_streamData)\n    ),\n    writer,\n    handlers: {\n      handleLLMNewToken: async (token) => {\n        await writer.ready;\n        await writer.write(token);\n      },\n      handleLLMStart: async (_llm, _prompts, runId) => {\n        handleStart(runId);\n      },\n      handleLLMEnd: async (_output, runId) => {\n        await handleEnd(runId);\n      },\n      handleLLMError: async (e, runId) => {\n        await handleError(e, runId);\n      },\n      handleChainStart: async (_chain, _inputs, runId) => {\n        handleStart(runId);\n      },\n      handleChainEnd: async (_outputs, runId) => {\n        await handleEnd(runId);\n      },\n      handleChainError: async (e, runId) => {\n        await handleError(e, runId);\n      },\n      handleToolStart: async (_tool, _input, runId) => {\n        handleStart(runId);\n      },\n      handleToolEnd: async (_output, runId) => {\n        await handleEnd(runId);\n      },\n      handleToolError: async (e, runId) => {\n        await handleError(e, runId);\n      }\n    }\n  };\n}\n\n// streams/replicate-stream.ts\nasync function ReplicateStream(res, cb) {\n  var _a;\n  const url = (_a = res.urls) == null ? void 0 : _a.stream;\n  if (!url) {\n    if (res.error)\n      throw new Error(res.error);\n    else\n      throw new Error(\"Missing stream URL in Replicate response\");\n  }\n  const eventStream = await fetch(url, {\n    method: \"GET\",\n    headers: {\n      Accept: \"text/event-stream\"\n    }\n  });\n  return AIStream(eventStream, void 0, cb).pipeThrough(\n    createStreamDataTransformer(cb == null ? void 0 : cb.experimental_streamData)\n  );\n}\nexport {\n  AIStream,\n  AnthropicStream,\n  COMPLEX_HEADER,\n  CohereStream,\n  HuggingFaceStream,\n  LangChainStream,\n  OpenAIStream,\n  ReplicateStream,\n  StreamStringPrefixes,\n  StreamingTextResponse,\n  createCallbacksTransformer,\n  createChunkDecoder,\n  createEventStreamTransformer,\n  createStreamDataTransformer,\n  experimental_StreamData,\n  getStreamString,\n  getStreamStringTypeAndValue,\n  isStreamStringEqualToType,\n  nanoid,\n  readableFromAsyncIterable,\n  streamToResponse,\n  trimStartOfStreamHelper\n};\n"],
  "mappings": "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",
  "names": ["createParser", "onParse", "isFirstChunk", "buffer", "startingPosition", "startingFieldLength", "eventId", "eventName", "data", "reset", "feed", "chunk", "hasBom", "slice", "BOM", "length", "position", "discardTrailingNewline", "lineLength", "fieldLength", "character", "index", "parseEventStreamLine", "lineBuffer", "type", "id", "event", "noValue", "field", "step", "valueLength", "value", "toString", "includes", "retry", "parseInt", "Number", "isNaN", "every", "charCode", "charCodeAt"]
}
